# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZpBLuIpUMTz2P_VFKfcsvpPd88H8b-Lw

### ğŸ“¦ Base: imports + dataclasses
"""

from __future__ import annotations
import json
import os
from dataclasses import dataclass, asdict
from pathlib import Path
from typing import Optional, Dict, Any

import requests

"""### ğŸ” CrossLogin Client (estilo do repo)"""

CROSSLOGIN_URLS = [
    "https://www.semsportal.com/api/v1/Common/CrossLogin",
    "https://www.semsportal.com/api/v2/Common/CrossLogin",
    "https://www.semsportal.com/api/v3/Common/CrossLogin",
]

DEFAULT_CLIENT = "web"        # o repo usa web/ios/android; web costuma funcionar bem
DEFAULT_VERSION = "v2.1.0"    # versÃ£o no header Token mÃ­nimo
DEFAULT_LANG = "en"


@dataclass
class GoodWeAuth:
    uid: str
    token: str
    timestamp: int          # epoch ms
    api_base: str           # ex.: https://us.semsportal.com/api/
    client: str = DEFAULT_CLIENT
    version: str = DEFAULT_VERSION
    language: str = DEFAULT_LANG

    @property
    def token_header_value(self) -> str:
        """
        Header `Token` exigido depois do CrossLogin: JSON stringificado com
        version/client/language/timestamp/uid/token.
        """
        payload = {
            "uid": self.uid,
            "timestamp": str(self.timestamp),
            "token": self.token,
            "client": self.client,
            "version": self.version,
            "language": self.language,
        }
        # precisa ser string JSON (nÃ£o dict)
        return json.dumps(payload, separators=(",", ":"))

    @property
    def base_api(self) -> str:
        return self.api_base if self.api_base.endswith("/") else (self.api_base + "/")

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GoodWeAuth":
        return GoodWeAuth(**d)


class GoodWeClient:
    """
    - CrossLogin (Token mÃ­nimo -> recebe token/uid/timestamp + api_base regional)
    - Session persistente com header Token completo
    - Helpers POST JSON / x-www-form-urlencoded
    """

    def __init__(
        self,
        account: str,
        password: str,
        *,
        client: str = DEFAULT_CLIENT,
        version: str = DEFAULT_VERSION,
        language: str = DEFAULT_LANG,
        token_cache_path: Optional[str | Path] = ".cache/goodwe_token.json",
        timeout: int = 30,
    ) -> None:
        self.account = account
        self.password = password
        self.client = client
        self.version = version
        self.language = language
        self.timeout = timeout

        self.session = requests.Session()
        self.session.headers.update({
            "Accept": "application/json",
            "User-Agent": "goodwe-notebook/0.1",
        })

        self.auth: Optional[GoodWeAuth] = None
        self.token_cache_path = Path(token_cache_path) if token_cache_path else None

        # tenta cache do token (se existir)
        if self.token_cache_path and self.token_cache_path.exists():
            try:
                cached = json.load(open(self.token_cache_path, "r", encoding="utf-8"))
                self.auth = GoodWeAuth.from_dict(cached)
                # injeta Token completo
                self.session.headers["Token"] = self.auth.token_header_value
            except Exception:
                self.auth = None

    def cross_login(self) -> GoodWeAuth:
        """
        ImplementaÃ§Ã£o no estilo do repo: manda Token MÃNIMO (sem uid/token),
        body {"account","pwd"}; recebe {data:{uid,token,timestamp}, api: <base>}.
        """
        minimal_token = json.dumps(
            {"client": self.client, "version": self.version, "language": self.language},
            separators=(",", ":"),
        )
        body = {"account": self.account, "pwd": self.password}

        last_exc: Optional[Exception] = None
        for url in CROSSLOGIN_URLS:
            try:
                r = self.session.post(url, headers={"Token": minimal_token}, json=body, timeout=self.timeout)
                r.raise_for_status()
                data = r.json()

                if (data.get("code") == 0 or data.get("hasError") is False) and "data" in data:
                    d = data["data"]
                    api_base = data.get("api") or data.get("components", {}).get("api")
                    if not api_base:
                        raise ValueError("CrossLogin OK, mas nÃ£o retornou 'api' (base regional).")

                    self.auth = GoodWeAuth(
                        uid=d["uid"],
                        token=d["token"],
                        timestamp=int(d["timestamp"]),
                        api_base=api_base,
                        client=self.client,
                        version=self.version,
                        language=self.language,
                    )
                    # Token COMPLETO nas prÃ³ximas requisiÃ§Ãµes
                    self.session.headers["Token"] = self.auth.token_header_value

                    # persiste em cache
                    if self.token_cache_path:
                        self.token_cache_path.parent.mkdir(parents=True, exist_ok=True)
                        json.dump(self.auth.to_dict(), open(self.token_cache_path, "w", encoding="utf-8"),
                                  ensure_ascii=False, indent=2)
                    return self.auth

                last_exc = RuntimeError(f"CrossLogin falhou em {url}: {data}")
            except Exception as e:
                last_exc = e

        raise RuntimeError(f"CrossLogin nÃ£o realizado. Ãšltimo erro: {last_exc}")

    def _ensure_auth(self) -> None:
        if not self.auth:
            self.cross_login()

    # -------- Helpers HTTP (region-aware) --------
    def post_json(self, endpoint: str, body: Dict[str, Any]) -> Dict[str, Any]:
        """
        POST JSON em {api_base}/{endpoint}
        """
        self._ensure_auth()
        url = self.auth.base_api + endpoint.lstrip("/")
        r = self.session.post(url, json=body, timeout=self.timeout,
                              headers={"Content-Type": "application/json", **self.session.headers})
        r.raise_for_status()
        return r.json()

    def post_form(self, endpoint: str, form: Dict[str, Any]) -> Dict[str, Any]:
        """
        POST x-www-form-urlencoded em {api_base}/{endpoint}
        """
        self._ensure_auth()
        url = self.auth.base_api + endpoint.lstrip("/")
        r = self.session.post(url, data=form, timeout=self.timeout,
                              headers={"Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
                                       **self.session.headers})
        r.raise_for_status()
        return r.json()

    # (opcional) chamada para URL absoluta (ignora api_base)
    def post_absolute_json(self, url: str, body: Dict[str, Any]) -> Dict[str, Any]:
        self._ensure_auth()
        r = self.session.post(url, json=body, timeout=self.timeout,
                              headers={"Content-Type": "application/json", **self.session.headers})
        r.raise_for_status()
        return r.json()

    def post_absolute_form(self, url: str, form: Dict[str, Any]) -> Dict[str, Any]:
        self._ensure_auth()
        r = self.session.post(url, data=form, timeout=self.timeout,
                              headers={"Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
                                       **self.session.headers})
        r.raise_for_status()
        return r.json()

"""### ğŸ§­ UtilitÃ¡rio de parÃ¢metros (pergunta e lembra pw_id, etc.)"""

class ParamResolver:
    """
    Pede ao usuÃ¡rio quando faltar (input), usa env vars e guarda em cache.
    Prioridade: argumento explÃ­cito > ENV > cache > input().
    """
    def __init__(self, cache_path: Optional[str | Path] = ".cache/goodwe_params.json"):
        self.cache_path = Path(cache_path) if cache_path else None
        self.cache: Dict[str, str] = {}
        if self.cache_path and self.cache_path.exists():
            try:
                self.cache = json.load(open(self.cache_path, "r", encoding="utf-8"))
            except Exception:
                self.cache = {}

    def _save(self) -> None:
        if not self.cache_path:
            return
        self.cache_path.parent.mkdir(parents=True, exist_ok=True)
        json.dump(self.cache, open(self.cache_path, "w", encoding="utf-8"), ensure_ascii=False, indent=2)

    def get(self, value: Optional[str], key: str, label_pt: Optional[str] = None) -> str:
        if value:
            self.cache[key] = value
            self._save()
            return value
        env_key = key.upper()
        v = os.getenv(env_key)
        if v:
            self.cache[key] = v
            self._save()
            return v
        if key in self.cache and self.cache[key]:
            return self.cache[key]
        prompt = label_pt or key
        v = input(f"Digite {prompt}: ").strip()
        if not v:
            raise ValueError(f"ParÃ¢metro obrigatÃ³rio nÃ£o informado: {key}")
        self.cache[key] = v
        self._save()
        return v

"""### âš™ï¸ â€œWire-upâ€: client + resolver (instÃ¢ncia Ãºnica que vocÃª vai reusar)"""

# instancie UMA vez e re-use
EMAIL = os.getenv("GOODWE_EMAIL", "demo@goodwe.com")
PASSWORD = os.getenv("GOODWE_PASSWORD", "GoodweSems123!@#")

gw = GoodWeClient(EMAIL, PASSWORD)
params = ParamResolver()

"""### ğŸ“¡ FunÃ§Ã£o 1 â€” QueryPowerStationMonitor (JSON)"""

def query_power_station_monitor(
    client: GoodWeClient,
    resolver: ParamResolver,
    *,
    powerstation_id: Optional[str] = None,
    key: str = "",
    orderby: str = "",
    powerstation_type: str = "",
    powerstation_status: str = "",
    page_index: int = 1,
    page_size: int = 14,
    adcode: str = "",
    org_id: str = "",
    condition: str = "",
    force_absolute_url: Optional[str] = None,  # ex.: "https://eu.semsportal.com/api/PowerStationMonitor/QueryPowerStationMonitor"
) -> Dict[str, Any]:
    """
    Retorna o JSON do endpoint QueryPowerStationMonitor.
    - Se powerstation_id faltar, pergunta ao usuÃ¡rio.
    - Usa POST JSON; por padrÃ£o, respeita a regiÃ£o do CrossLogin.
    - Se quiser forÃ§ar 'eu.' (ou outro host), passe 'force_absolute_url'.
    """
    ps_id = resolver.get(powerstation_id, "powerstation_id", "o PowerStationId (powerstation_id)")
    body = {
        "powerstation_id": ps_id,
        "key": key,
        "orderby": orderby,
        "powerstation_type": powerstation_type,
        "powerstation_status": powerstation_status,
        "page_index": page_index,
        "page_size": page_size,
        "adcode": adcode,
        "org_id": org_id,
        "condition": condition,
    }

    if force_absolute_url:
        return client.post_absolute_json(force_absolute_url, body)
    # caminho relativo sob a api_base regional
    endpoint = "PowerStationMonitor/QueryPowerStationMonitor"
    return client.post_json(endpoint, body)

"""### âš¡ FunÃ§Ã£o 2 â€” GetInverterAllPoint (form-urlencoded)"""

def get_inverter_all_point(
    client: GoodWeClient,
    resolver: ParamResolver,
    *,
    power_station_id: Optional[str] = None,
    force_absolute_url: Optional[str] = None,  # ex.: "https://us.semsportal.com/api/v3/PowerStation/GetInverterAllPoint"
) -> Dict[str, Any]:
    """
    Retorna o JSON do endpoint v3/PowerStation/GetInverterAllPoint (form-urlencoded).
    - Pede powerStationId (se necessÃ¡rio).
    - Usa POST form; por padrÃ£o, respeita a regiÃ£o do CrossLogin.
    - Se quiser forÃ§ar 'us.' (ou outro host), passe 'force_absolute_url'.
    """
    ps_id = resolver.get(power_station_id, "pw_id", "o PowerStationId (pw_id)")
    form = {"powerStationId": ps_id}

    if force_absolute_url:
        return client.post_absolute_form(force_absolute_url, form)
    endpoint = "v3/PowerStation/GetInverterAllPoint"
    return client.post_form(endpoint, form)

"""### â–¶ï¸ Exemplo de uso (uma cÃ©lula de teste)"""

# 1) Login (usa cache se existir)
auth = gw.cross_login()
print("API base regional:", auth.api_base)

# 2) Chamar os endpoints
try:
    # QueryPowerStationMonitor (JSON)
    qpsm = query_power_station_monitor(
        gw, params,
        # force_absolute_url="https://eu.semsportal.com/api/PowerStationMonitor/QueryPowerStationMonitor",  # opcional
    )
    print("QueryPowerStationMonitor => code:", qpsm.get("code"), "| hasError:", qpsm.get("hasError"))
except Exception as e:
    print("Erro QueryPowerStationMonitor:", e)

try:
    # GetInverterAllPoint (form)
    inv_all = get_inverter_all_point(
        gw, params,
        # force_absolute_url="https://us.semsportal.com/api/v3/PowerStation/GetInverterAllPoint",  # opcional
    )
    print("GetInverterAllPoint => code:", inv_all.get("code"), "| hasError:", inv_all.get("hasError"))
except Exception as e:
    print("Erro GetInverterAllPoint:", e)

"""### ğŸ§° Helper â€” imprimir e salvar JSON"""

# === Helper â€” imprimir e salvar JSON ===
from pathlib import Path
import json

def show_json(title: str, data, *, max_chars: int | None = None) -> None:
    print(f"\n# {title}")
    text = json.dumps(data, ensure_ascii=False, indent=2)
    if max_chars and len(text) > max_chars:
        print(text[:max_chars] + "\n... [truncado]")
    else:
        print(text)

def save_json(data, path: str | Path) -> Path:
    path = Path(path)
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)
    print(f"âœ“ salvo em: {path.resolve()}")
    return path

"""### â–¶ï¸ Executar & exibir â€” QueryPowerStationMonitor"""

# === Executar & exibir â€” QueryPowerStationMonitor ===
qpsm = query_power_station_monitor(
    gw, params,
    # force_absolute_url="https://eu.semsportal.com/api/PowerStationMonitor/QueryPowerStationMonitor",  # opcional
)
show_json("QueryPowerStationMonitor â€” resposta completa", qpsm)
save_json(qpsm, "results/QueryPowerStationMonitor.json")

"""### â–¶ï¸ Executar & exibir â€” GetInverterAllPoint"""

# === Executar & exibir â€” GetInverterAllPoint ===
inv_all = get_inverter_all_point(
    gw, params,
    # force_absolute_url="https://us.semsportal.com/api/v3/PowerStation/GetInverterAllPoint",  # opcional
)
show_json("GetInverterAllPoint â€” resposta completa", inv_all)
save_json(inv_all, "results/GetInverterAllPoint.json")

"""### ğŸ§° Helpers de formataÃ§Ã£o (energia, potÃªncia, nÃºmeros, status, clima)"""

# === Helpers de formataÃ§Ã£o (energia, potÃªncia, nÃºmeros, status, clima) ===
from typing import Optional

def fmt_num(x: Optional[float]) -> str:
    if x is None:
        return "-"
    if isinstance(x, (int, float)):
        return f"{x:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
    return str(x)

def fmt_energy_from_kwh(kwh: Optional[float]) -> str:
    """Converte kWh para kWh/MWh/GWh com sufixo apropriado."""
    if kwh is None:
        return "-"
    try:
        kwh = float(kwh)
    except Exception:
        return "-"
    if kwh >= 1_000_000:
        return f"{kwh/1_000_000:.2f} GWh".replace(".", ",")
    if kwh >= 1_000:
        return f"{kwh/1_000:.2f} MWh".replace(".", ",")
    return f"{kwh:.2f} kWh".replace(".", ",")

def fmt_power_w_or_kw(pac: Optional[float], pac_kw: Optional[float] = None) -> str:
    """
    Prefere 'pac_kw' se existir; do contrÃ¡rio, tenta inferir de 'pac' (W).
    """
    if pac_kw is not None:
        try:
            v = float(pac_kw)
            return f"{v:.2f} kW".replace(".", ",")
        except Exception:
            pass
    if pac is None:
        return "-"
    try:
        v = float(pac)
    except Exception:
        return "-"
    # HeurÃ­stica: valores > 1000 provavelmente estÃ£o em Watts â†’ converte p/ kW.
    if v >= 1000:
        return f"{(v/1000):.2f} kW".replace(".", ",")
    # Caso contrÃ¡rio, assume que jÃ¡ estÃ¡ em kW (raro, mas possÃ­vel)
    return f"{v:.2f} kW".replace(".", ",")

def fmt_capacity(capacity_raw: Optional[float]) -> str:
    """
    Muitos retornam 'capacity' ~ 3600.0 (provÃ¡vel Watts) â†’ mostra em kW.
    """
    if capacity_raw is None:
        return "-"
    try:
        v = float(capacity_raw)
    except Exception:
        return "-"
    if v >= 1000:
        return f"{(v/1000):.1f} kW".replace(".", ",")
    return f"{v:.1f} kW".replace(".", ",")

def map_status(code: Optional[int]) -> str:
    """
    Mapa amigÃ¡vel para status da usina.
    ObservaÃ§Ã£o: esses cÃ³digos variam entre versÃµes; mantemos 'fallback' seguro.
    """
    mapping = {
        -1: "Offline/Desconhecido",
         0: "OK/Normal",
         1: "AtenÃ§Ã£o",
         2: "Alarme",
    }
    if code in mapping:
        return mapping[code]
    return f"Status {code}"

def extract_weather(weather: dict) -> dict:
    """
    Extrai tempo atual do bloco HeWeather6 -> [0] -> now.
    Retorna dict com cond, temp, umidade, vento.
    """
    try:
        hw = weather.get("HeWeather6", [{}])[0]
        now = hw.get("now", {})
        return {
            "cond_txt": now.get("cond_txt"),
            "tmp_c": now.get("tmp"),
            "hum_pct": now.get("hum"),
            "wind_spd": now.get("wind_spd"),
            "wind_dir": now.get("wind_dir"),
        }
    except Exception:
        return {}

"""### ğŸ–¼ï¸ Renderer â€” mensagem bonita para QueryPowerStationMonitor"""

# === Renderer â€” mensagem bonita para QueryPowerStationMonitor ===
def render_qpsm_message(qpsm_json: dict, *, include_weather: bool = True) -> str:
    """
    Recebe o JSON do endpoint QueryPowerStationMonitor e monta uma mensagem amigÃ¡vel.
    Suporta lista com 1..N usinas (data.list).
    """
    if not isinstance(qpsm_json, dict):
        return "Resposta invÃ¡lida."
    code = qpsm_json.get("code")
    has_error = qpsm_json.get("hasError")
    msg = qpsm_json.get("msg", "")
    if has_error or code != 0:
        return f"âš ï¸ Erro da API (code={code}): {msg}"

    data = qpsm_json.get("data", {})
    items = data.get("list", [])
    if not items:
        return "Nenhuma usina encontrada para os filtros informados."

    lines = []
    header = f"âœ… {len(items)} usina(s) encontrada(s)"
    lines.append(header)
    lines.append("")

    for i, st in enumerate(items, 1):
        name = st.get("stationname") or st.get("powerstation_name") or "Sem nome"
        loc = st.get("location") or "-"
        currency = st.get("currency") or "-"
        status_text = map_status(st.get("status"))
        pac = fmt_power_w_or_kw(st.get("pac"), st.get("pac_kw"))
        capacity = fmt_capacity(st.get("capacity"))
        eday = fmt_energy_from_kwh(st.get("eday"))
        emonth = fmt_energy_from_kwh(st.get("emonth"))
        etotal = fmt_energy_from_kwh(st.get("etotal"))
        yield_rate = fmt_num(st.get("yield_rate"))
        lat = st.get("latitude")
        lon = st.get("longitude")
        coords = f"{lat}, {lon}" if lat and lon else "-"
        org_name = st.get("org_name") or "-"
        ps_id = st.get("powerstation_id") or "-"

        # bloco tempo
        weather_block = ""
        if include_weather and isinstance(st.get("weather"), dict):
            w = extract_weather(st["weather"])
            if any(w.values()):
                weather_block = (
                    f"\n   â€¢ â˜€ï¸ Clima agora: {w.get('cond_txt') or '-'}"
                    f" | ğŸŒ¡ï¸ {w.get('tmp_c') or '-'}Â°C"
                    f" | ğŸ’§ {w.get('hum_pct') or '-'}%"
                    f" | ğŸŒ¬ï¸ {w.get('wind_spd') or '-'} km/h {w.get('wind_dir') or ''}"
                )

        # Link de mapa (markdown) se houver coordenadas
        map_link = ""
        if lat and lon:
            map_url = f"https://maps.google.com/?q={lat},{lon}"
            map_link = f"\n   â€¢ ğŸ—ºï¸ Mapa: {map_url}"

        # cartÃ£o
        card = [
            f"### {i}. {name}",
            f"   â€¢ ğŸ·ï¸ ID: `{ps_id}`",
            f"   â€¢ ğŸ“ Local: {loc}",
            f"   â€¢ ğŸ§­ Coord: {coords}",
            f"   â€¢ ğŸ¢ OrganizaÃ§Ã£o: {org_name}",
            f"   â€¢ ğŸ’¡ Capacidade: {capacity}",
            f"   â€¢ âš¡ PotÃªncia atual: {pac}",
            f"   â€¢ ğŸ“… Hoje: {eday} | ğŸ—“ï¸ MÃªs: {emonth} | ğŸ§® Total: {etotal}",
            f"   â€¢ ğŸ“ˆ Yield rate: {yield_rate}%",
            f"   â€¢ ğŸ§© Estado: {status_text}",
            f"   â€¢ ğŸ’± Moeda: {currency}",
        ]
        # extras
        if weather_block:
            card.append(weather_block)
        if map_link:
            card.append(map_link)

        # separador visual entre usinas
        lines.append("\n".join(card))
        if i < len(items):
            lines.append("\n" + "â€”" * 60 + "\n")

    return "\n".join(lines)

message = render_qpsm_message(qpsm, include_weather=True)
print(message)

"""### ğŸ§° Helpers especÃ­ficos â€” GetInverterAllPoint"""

# === 14) Helpers especÃ­ficos â€” GetInverterAllPoint ===
from typing import Tuple, Optional, Dict, Any, List

def _pairs_to_map(block: Dict[str, Any]) -> Dict[str, Dict[str, Any]]:
    """
    Converte os arrays 'left' e 'right' (cada item com key/value/unit) em um dict:
      { <key>: {"value": <str>, "unit": <str>, ...}, ... }
    """
    result: Dict[str, Dict[str, Any]] = {}
    if not isinstance(block, dict):
        return result
    for side in ("left", "right"):
        items: List[Dict[str, Any]] = block.get(side) or []
        for it in items:
            k = it.get("key")
            if k:
                result[k] = it
    return result

def _get_val(m: Dict[str, Dict[str, Any]], key: str, default: str = "-") -> str:
    it = m.get(key)
    if not it:
        return default
    v = it.get("value")
    return default if v in (None, "") else str(v)

def _parse_dc_va(s: Optional[str]) -> Tuple[Optional[float], Optional[float]]:
    """
    '0.0/0.0' -> (0.0 V, 0.0 A). Retorna (None, None) se nÃ£o der pra parsear.
    """
    if not s or not isinstance(s, str):
        return (None, None)
    try:
        v, a = s.split("/", 1)
        return (float(v), float(a))
    except Exception:
        return (None, None)

def _fmt_kw(value) -> str:
    try:
        f = float(value)
        return f"{f:.2f} kW".replace(".", ",")
    except Exception:
        return str(value) if value is not None else "-"

"""### ğŸ–¼ï¸ Renderer â€” mensagem bonita para GetInverterAllPoint"""

# === 15) Renderer â€” mensagem bonita para GetInverterAllPoint ===
def render_get_inverter_all_point(inv_json: dict) -> str:
    """
    Recebe o JSON do endpoint v3/PowerStation/GetInverterAllPoint e monta uma mensagem amigÃ¡vel.
    Usa helpers jÃ¡ definidos anteriormente (fmt_energy_from_kwh, fmt_num, map_status), se existirem.
    """
    # robustez: aceita code "0" como string ou 0 inteiro
    code = inv_json.get("code")
    if str(code) != "0" or inv_json.get("hasError") is True:
        return f"âš ï¸ Erro da API (code={code}): {inv_json.get('msg', '')}"

    data = inv_json.get("data", {})
    items = data.get("inverterPoints") or []
    if not items:
        return "Nenhum inversor retornado."

    out_lines: List[str] = []
    out_lines.append(f"âœ… {len(items)} inversor(es) encontrado(s)\n")

    for idx, inv in enumerate(items, 1):
        sn   = inv.get("sn") or "-"
        name = inv.get("name") or "-"
        status_text = map_status(inv.get("status")) if "map_status" in globals() else str(inv.get("status"))

        # energia & potÃªncia
        eday   = fmt_energy_from_kwh(inv.get("eday"))   if "fmt_energy_from_kwh" in globals() else str(inv.get("eday"))
        emonth = fmt_energy_from_kwh(inv.get("emonth")) if "fmt_energy_from_kwh" in globals() else str(inv.get("emonth"))
        etotal = fmt_energy_from_kwh(inv.get("etotal")) if "fmt_energy_from_kwh" in globals() else str(inv.get("etotal"))

        in_pac  = _fmt_kw(inv.get("in_pac"))
        out_pac = _fmt_kw(inv.get("out_pac"))

        # extras
        soc      = inv.get("soc") or "-"
        htotal   = fmt_num(inv.get("hTotal")) + " h" if "fmt_num" in globals() else f"{inv.get('hTotal')} h"
        last_ref = inv.get("last_refresh_time") or "-"
        local_dt = inv.get("local_date") or "-"
        grid     = inv.get("gridConnStatus") or "-"

        # pares de mÃ©tricas (AC/DC/temperatura/RSSI/etc.)
        pairs_map = _pairs_to_map(inv.get("dict") or {})
        ac_v   = _get_val(pairs_map, "acVacVol")
        ac_i   = _get_val(pairs_map, "acCurrent")
        ac_f   = _get_val(pairs_map, "acFrequency")
        pf     = _get_val(pairs_map, "PF")
        temp_i = _get_val(pairs_map, "innerTemp")
        rssi   = _get_val(pairs_map, "RSSI", "--")
        cap_kw = _get_val(pairs_map, "DeviceParameter_capacity")  # jÃ¡ vem com "kW" no unit

        dc1_v, dc1_a = _parse_dc_va(_get_val(pairs_map, "dcVandC1"))
        dc2_v, dc2_a = _parse_dc_va(_get_val(pairs_map, "dcVandC2"))

        # bateria (se existir)
        vb = inv.get("vbattery1")
        ib = inv.get("ibattery1")
        vb_txt = f"{vb} V" if vb is not None else "-"
        ib_txt = f"{ib} A" if ib is not None else "-"

        # cartÃ£o bonito
        lines = [
            f"### {idx}. {name} (SN: `{sn}`)",
            f"   â€¢ ğŸ§© Estado: {status_text}",
            f"   â€¢ âš¡ PotÃªncia: Entrada {in_pac} | SaÃ­da {out_pac}",
            f"   â€¢ ğŸ“ˆ Energia: Hoje {eday} | MÃªs {emonth} | Total {etotal}",
            f"   â€¢ â± Ãšltima att.: {last_ref} | Local: {local_dt}",
            f"   â€¢ ğŸ”Œ AC: V={ac_v} V | I={ac_i} A | f={ac_f} Hz | PF={pf if pf != '-' else '-'}",
            f"   â€¢ â˜€ï¸ DC1: V={('-' if dc1_v is None else str(dc1_v))} V | A={('-' if dc1_a is None else str(dc1_a))} A",
            f"   â€¢ â˜€ï¸ DC2: V={('-' if dc2_v is None else str(dc2_v))} V | A={('-' if dc2_a is None else str(dc2_a))} A",
            f"   â€¢ ğŸŒ¡ Temp. interna: {temp_i} â„ƒ",
            f"   â€¢ ğŸ”‹ Bateria: SOC={soc} | V={vb_txt} | I={ib_txt}",
            f"   â€¢ ğŸ§® Horas Totais: {htotal}",
            f"   â€¢ ğŸ“¶ RSSI: {rssi}",
            f"   â€¢ ğŸ§± Capacidade (decl.): {cap_kw or '-'}",
            f"   â€¢ ğŸ”— Grid: {grid or '-'}",
        ]

        out_lines.append("\n".join(lines))
        if idx < len(items):
            out_lines.append("\n" + "â€”" * 60 + "\n")

    return "\n".join(out_lines)

"""### â–¶ï¸ Uso â€” renderizar a mensagem a partir de inv_all"""

# === 16) Uso â€” renderizar a mensagem a partir de 'inv_all' ===
# pressupondo que 'inv_all' jÃ¡ contÃ©m o JSON de GetInverterAllPoint (como vocÃª mostrou)
message_inverters = render_get_inverter_all_point(inv_all)
print(message_inverters)

"""### ğŸ” ParamResolver â€” versÃ£o â€œsempre perguntar & sobrescreverâ€"""

# === 23) ParamResolver â€” sempre perguntar & sobrescrever ===
import os, json
from pathlib import Path
from typing import Optional, Dict

class ParamResolver:
    """
    Sempre pergunta e sobrescreve o valor (mesmo que exista em ENV/cache).
    Prioridade efetiva: argumento explÃ­cito > (pergunta ao usuÃ¡rio; se vazio, cai no valor atual, se existir)
    """
    def __init__(self, cache_path: Optional[str | Path] = ".cache/goodwe_params.json"):
        self.cache_path = Path(cache_path) if cache_path else None
        self.cache: Dict[str, str] = {}
        if self.cache_path and self.cache_path.exists():
            try:
                self.cache = json.load(open(self.cache_path, "r", encoding="utf-8"))
            except Exception:
                self.cache = {}

    def _save(self) -> None:
        if not self.cache_path:
            return
        self.cache_path.parent.mkdir(parents=True, exist_ok=True)
        json.dump(self.cache, open(self.cache_path, "w", encoding="utf-8"),
                  ensure_ascii=False, indent=2)

    def get(self, value: Optional[str], key: str, label_pt: Optional[str] = None) -> str:
        # Se veio valor explÃ­cito via argumento, usa e persiste
        if value:
            self.cache[key] = value
            self._save()
            return value

        # Valor atual (se existir) â€” apenas para mostrar no prompt e fallback se usuÃ¡rio der Enter
        env_val = os.getenv(key.upper())
        cur = env_val if env_val else self.cache.get(key)

        # Pergunta SEMPRE
        prompt_label = label_pt or key
        suffix = f" (atual: {cur})" if cur else ""
        typed = input(f"Digite {prompt_label}{suffix}: ").strip()

        # Se usuÃ¡rio sÃ³ apertar Enter, usa o valor atual (se existir)
        if not typed:
            if cur:
                typed = cur
            else:
                raise ValueError(f"ParÃ¢metro obrigatÃ³rio nÃ£o informado: {key}")

        # Sobrescreve cache e retorna
        self.cache[key] = typed
        self._save()
        return typed

# === 24) Reinstanciar o resolver ===
params = ParamResolver()  # sempre pergunta e sobrescreve

"""### â–¶ï¸ Chamadas â€” sempre perguntando IDs a cada execuÃ§Ã£o"""

# === 25) Login + chamadas (sempre pergunta os parÃ¢metros) ===
auth = gw.cross_login()
print("API base regional:", auth.api_base)

try:
    qpsm = query_power_station_monitor(
        gw, params,
        # force_absolute_url="https://eu.semsportal.com/api/PowerStationMonitor/QueryPowerStationMonitor",
    )
    print("QueryPowerStationMonitor => code:", qpsm.get("code"), "| hasError:", qpsm.get("hasError"))
except Exception as e:
    print("Erro QueryPowerStationMonitor:", e)

try:
    inv_all = get_inverter_all_point(
        gw, params,
        # force_absolute_url="https://us.semsportal.com/api/v3/PowerStation/GetInverterAllPoint",
    )
    print("GetInverterAllPoint => code:", inv_all.get("code"), "| hasError:", inv_all.get("hasError"))
except Exception as e:
    print("Erro GetInverterAllPoint:", e)

"""### ğŸ“¡ FunÃ§Ã£o â€” get_weather(...)"""

# === 26) FunÃ§Ã£o â€” GetWeather (form-urlencoded) ===
def get_weather(
    client: GoodWeClient,
    resolver: ParamResolver,
    *,
    power_station_id: Optional[str] = None,
    force_absolute_url: Optional[str] = None,  # ex.: "https://eu.semsportal.com/api/v3/PowerStation/GetWeather"
) -> Dict[str, Any]:
    """
    Chama v3/PowerStation/GetWeather e retorna o JSON.
    - Sempre pergunta/sobrescreve o PowerStationId (via ParamResolver atual).
    - Por padrÃ£o usa a api_base regional do CrossLogin; se quiser travar 'eu.', use force_absolute_url.
    """
    ps_id = resolver.get(power_station_id, "pw_id", "o PowerStationId (pw_id)")
    form = {"powerStationId": ps_id}

    if force_absolute_url:
        return client.post_absolute_form(force_absolute_url, form)
    endpoint = "v3/PowerStation/GetWeather"
    return client.post_form(endpoint, form)

"""### ğŸ§° Helpers â€” emojis de condiÃ§Ã£o, vento, nÃºmeros, datas"""

# === 27) Helpers â€” emojis, vento, nÃºmeros, datas ===
from datetime import datetime
from typing import Optional, Dict, Any, List, Tuple

def weather_emoji(txt: Optional[str]) -> str:
    if not txt:
        return "ğŸŒ¤ï¸"
    t = txt.lower()
    if "thunder" in t:    return "â›ˆï¸"
    if "shower" in t:     return "ğŸŒ§ï¸"
    if "light rain" in t: return "ğŸŒ¦ï¸"
    if "rain" in t:       return "ğŸŒ§ï¸"
    if "overcast" in t:   return "â˜ï¸"
    if "cloud" in t:      return "ğŸŒ¤ï¸"  # few/partly clouds
    if "sunny" in t:      return "â˜€ï¸"
    if "clear" in t:      return "ğŸŒ™"
    return "ğŸŒ¤ï¸"

def arrow_from_dir(dir_txt: Optional[str]) -> str:
    if not dir_txt: return ""
    d = dir_txt.upper()
    mapping = {
        "N":"â¬†ï¸","NNE":"â†—ï¸","NE":"â†—ï¸","ENE":"â†—ï¸",
        "E":"â¡ï¸","ESE":"â†˜ï¸","SE":"â†˜ï¸","SSE":"â†˜ï¸",
        "S":"â¬‡ï¸","SSW":"â†™ï¸","SW":"â†™ï¸","WSW":"â†™ï¸",
        "W":"â¬…ï¸","WNW":"â†–ï¸","NW":"â†–ï¸","NNW":"â†–ï¸",
    }
    return mapping.get(d, "")

def fmt_pct(x: Optional[str|float|int]) -> str:
    if x is None: return "-"
    try: return f"{float(x):.0f}%"
    except: return str(x)

def fmt_mm(x: Optional[str|float]) -> str:
    if x is None: return "-"
    try: return f"{float(x):.1f} mm".replace(".", ",")
    except: return str(x)

def fmt_c(x: Optional[str|float]) -> str:
    if x is None: return "-"
    try: return f"{float(x):.0f}Â°C"
    except: return str(x)

def fmt_num(x: Optional[float|int|str]) -> str:
    if x is None: return "-"
    try:
        v = float(x)
        return f"{v:,.0f}".replace(",", "X").replace(".", ",").replace("X", ".")
    except:
        return str(x)

PT_DAYS = ["Seg", "Ter", "Qua", "Qui", "Sex", "SÃ¡b", "Dom"]
def day_name(date_str: str) -> str:
    # date Ã© "YYYY-MM-DD"
    try:
        d = datetime.strptime(date_str, "%Y-%m-%d")
        # Monday=0 -> "Seg"
        return PT_DAYS[d.weekday()]
    except:
        return date_str

"""### ğŸ–¼ï¸ Renderer â€” mensagem bonita para GetWeather (7 dias)"""

# === 31) Renderer v2 â€” GetWeather (robusto) ===
from typing import Dict, Any, List

def render_get_weather_v2(weather_json: Dict[str, Any]) -> str:
    """
    VersÃ£o mais robusta do renderer de v3/PowerStation/GetWeather.
    - Se 'daily_forecast' estiver vazio/ausente, explica o motivo.
    - DivisÃ³ria ajustada para uma linha Ãºnica.
    """
    code = str(weather_json.get("code"))
    if code != "0" or weather_json.get("hasError") is True:
        return f"âš ï¸ Erro da API (code={code}): {weather_json.get('msg','')}"

    # PowerStationId (se vier em components)
    ps_id = "-"
    try:
        para = weather_json.get("components", {}).get("para")
        if para:
            model = json.loads(para).get("model", {})
            ps_id = model.get("PowerStationId") or "-"
    except Exception:
        pass

    # Extrair daily_forecast
    days: List[Dict[str, Any]] = []
    try:
        he = weather_json["data"]["weather"]["HeWeather6"][0]
        days = he.get("daily_forecast") or []
    except Exception:
        pass

    header = f"ğŸ“… PrevisÃ£o (7 dias) â€” PowerStationId: `{ps_id}`"
    if not days:
        return (
            header
            + "\n"
            + "â€”" * 48
            + "\nSem dados em 'daily_forecast'.\n"
              "Se vocÃª usou o exemplo estÃ¡tico (29b), cole os 7 itens da resposta real, "
              "ou chame a API com get_weather(gw, params) para preencher automaticamente."
        )

    lines: List[str] = [header, ""]

    # Resumo agregador
    max_hot = None   # (valor, idx)
    min_cold = None  # (valor, idx)
    rainy_idx = None # primeiro dia com chuva relevante (>=1 mm ou >=50%)

    for i, d in enumerate(days):
        date = d.get("date", "-")
        dow  = day_name(date)
        cond_d = d.get("cond_txt_d", "")
        cond_n = d.get("cond_txt_n", "")
        e_d = weather_emoji(cond_d)
        e_n = weather_emoji(cond_n)

        tmax = d.get("tmp_max")
        tmin = d.get("tmp_min")
        hum  = d.get("hum")
        pop  = d.get("pop")
        pcpn = d.get("pcpn")
        uv   = d.get("uv_index")
        vis  = d.get("vis")
        w_dir = d.get("wind_dir")
        w_spd = d.get("wind_spd")
        w_arr = arrow_from_dir(w_dir)

        # acumula para resumo
        try:
            fmax = float(tmax)
            if (max_hot is None) or (fmax > max_hot[0]):
                max_hot = (fmax, i)
        except: pass
        try:
            fmin = float(tmin)
            if (min_cold is None) or (fmin < min_cold[0]):
                min_cold = (fmin, i)
        except: pass
        try:
            fpc = float(pcpn or 0)
            fpp = float(pop or 0)
            if rainy_idx is None and (fpc >= 1.0 or fpp >= 50.0):
                rainy_idx = i
        except: pass

        # bloco do dia
        lines.append(
            f"**{dow} {date}**  {e_d} {cond_d} / {e_n} {cond_n}\n"
            f"   â€¢ ğŸŒ¡ï¸ MÃ¡x: {fmt_c(tmax)} | MÃ­n: {fmt_c(tmin)} | ğŸ’§ Umidade: {fmt_pct(hum)}\n"
            f"   â€¢ ğŸŒ§ï¸ Chuva: {fmt_mm(pcpn)} (prob.: {fmt_pct(pop)}) | ğŸ”† UV: {fmt_num(uv)} | ğŸ‘ï¸ Vis: {fmt_num(vis)} km\n"
            f"   â€¢ ğŸŒ¬ï¸ Vento: {w_arr} {w_dir or '-'} {fmt_num(w_spd)} km/h"
        )
        if i < len(days) - 1:
            lines.append("")

    # Resumo final
    lines.append("â€”" * 48)
    lines.append("**Resumo rÃ¡pido**")
    if max_hot:
        idx = max_hot[1]
        lines.append(f"â€¢ ğŸ”¥ Dia mais quente: {day_name(days[idx]['date'])} {days[idx]['date']} (mÃ¡x {fmt_c(days[idx]['tmp_max'])})")
    if min_cold:
        idx = min_cold[1]
        lines.append(f"â€¢ â„ï¸ Noite mais fria: {day_name(days[idx]['date'])} {days[idx]['date']} (mÃ­n {fmt_c(days[idx]['tmp_min'])})")
    if rainy_idx is not None:
        di = days[rainy_idx]
        lines.append(f"â€¢ â˜” PrÃ³ximo dia com chuva relevante: {day_name(di['date'])} {di['date']} "
                     f"({fmt_mm(di.get('pcpn'))}, prob. {fmt_pct(di.get('pop'))})")
    else:
        lines.append("â€¢ â˜” Sem chuva relevante prevista nos prÃ³ximos dias.")

    return "\n".join(lines)

"""### â–¶ï¸ Uso â€” a) chamando a API ou b) usando seu JSON jÃ¡ obtido"""

# === 34) GetWeather (API real) â†’ render ===
# Usa o client autenticado (gw) e o ParamResolver (params) para buscar o JSON da API
# e imprime a mensagem formatada (v2 do renderer).

# 1) Garante login/cookies/Token prontos
auth = gw.cross_login()
print(auth)
print("API base regional:", auth.api_base)

# 2) Chama a API de verdade (vai pedir o PowerStationId e sobrescrever se for o seu ParamResolver 'sempre perguntar')
wjson = get_weather(gw, params)

# 3) Renderiza mensagem bonita a partir do JSON retornado pela API
print(render_get_weather_v2(wjson))

"""### ğŸ“¡ FunÃ§Ã£o â€” GetPlantPowerChart"""

# === 36) FunÃ§Ã£o â€” GetPlantPowerChart (v2/Charts/GetPlantPowerChart) ===
from typing import Optional, Dict, Any, List
from datetime import date as _date

def _post_power_chart_for_date(
    client: GoodWeClient,
    chart_id: str,
    the_date_str: str,
    *,
    force_absolute_url: Optional[str] = None,
    full_script: bool = True,
) -> Dict[str, Any]:
    """Chama a API para **um dia** e retorna o JSON bruto desse dia."""
    body = {"id": chart_id, "date": the_date_str, "full_script": bool(full_script)}
    if force_absolute_url:
        return client.post_absolute_json(force_absolute_url, body)
    endpoint = "v2/Charts/GetPlantPowerChart"
    return client.post_json(endpoint, body)

def get_plant_power_chart(
    client: GoodWeClient,
    resolver: ParamResolver,
    *,
    plant_id: Optional[str] = None,        # API chama de "id"
    period: Optional[str] = None,          # "1"=Dia, "2"=Semana, "3"=MÃªs (texto tambÃ©m aceito)
    ref_date: Optional[str] = None,        # "YYYY-MM-DD"
    full_script: bool = True,
    force_absolute_url: Optional[str] = None,  # ex.: "https://eu.semsportal.com/api/v2/Charts/GetPlantPowerChart"
) -> Dict[str, Any]:
    """
    Chama v2/Charts/GetPlantPowerChart:
      â€¢ Dia   -> 1 chamada (ref_date)
      â€¢ Semana-> 7 chamadas (segunda..domingo da semana de ref_date)
      â€¢ MÃªs   -> N chamadas (1Âº..Ãºltimo dia do mÃªs de ref_date)
    Retorna:
      â€¢ Para Dia: JSON bruto do endpoint (compatÃ­vel com versÃµes anteriores).
      â€¢ Para Semana/MÃªs: um "bundle" agregado com os JSONs diÃ¡rios + somatÃ³rios.
    """
    chart_id = resolver.get(plant_id, "plant_id", "o ID da usina para o grÃ¡fico (id)")
    period_opt = resolver.get(period, "chart_period", "o perÃ­odo [1=Dia, 2=Semana, 3=MÃªs]")
    ref_date_input = resolver.get(ref_date, "chart_ref_date", "a data de referÃªncia (YYYY-MM-DD)")

    period_norm = _normalize_period(period_opt)
    # lista de datas a consultar (YYYY-MM-DD)
    all_dates: List[str] = compute_period_dates(period_norm, ref_date_input)

    # DIA â†’ retorna exatamente o JSON do endpoint (retrocompatÃ­vel)
    if period_norm == "1":
        return _post_power_chart_for_date(client, chart_id, all_dates[0],
                                          force_absolute_url=force_absolute_url, full_script=full_script)

    # SEMANA/MÃŠS â†’ agregar mÃºltiplos dias
    items: List[Dict[str, Any]] = []
    for dstr in all_dates:
        try:
            j = _post_power_chart_for_date(client, chart_id, dstr,
                                           force_absolute_url=force_absolute_url, full_script=full_script)
            items.append({"date": dstr, "json": j})
        except Exception as e:
            items.append({"date": dstr, "error": str(e)})

    # calcula agregados (soma Generation/Income; picos globais PV/Load/Battery/Meter; SOC inicial/final)
    aggregate = aggregate_power_chart_items(items)

    return {
        "_period_kind": "week" if period_norm == "2" else "month",
        "_id": chart_id,
        "start_date": all_dates[0],
        "end_date": all_dates[-1],
        "items": items,         # lista com cada dia e seu json
        "aggregate": aggregate, # soma/picos/SOC do perÃ­odo
    }

"""### ğŸ§° Helpers â€” perÃ­odo (Dia/Semana/MÃªs)"""

# === 37) Helpers â€” perÃ­odoâ†’datas + agregaÃ§Ã£o + utilidades ===
from datetime import datetime, timedelta, date
from typing import List, Tuple, Optional, Dict, Any
import calendar
import math
import json

def _parse_date_yyyy_mm_dd(s: Optional[str]) -> date:
    if not s:
        return date.today()
    try:
        return datetime.strptime(s, "%Y-%m-%d").date()
    except Exception:
        return date.today()

def _normalize_period(p: Optional[str]) -> str:
    if not p:
        return "1"
    t = str(p).strip().lower()
    if t in ("1", "dia", "d", "day"): return "1"
    if t in ("2", "semana", "s", "week"): return "2"
    if t in ("3", "mÃªs", "mes", "m", "month"): return "3"
    return "1"

def compute_chart_date(period_opt: str, ref_date_str: Optional[str]) -> str:
    """Mantido para compatibilidade (usa o inÃ­cio do perÃ­odo)."""
    period_norm = _normalize_period(period_opt)
    d = _parse_date_yyyy_mm_dd(ref_date_str)
    if period_norm == "1":  # Dia
        return d.strftime("%Y-%m-%d")
    if period_norm == "2":  # Semana -> segunda
        monday = d - timedelta(days=d.weekday())
        return monday.strftime("%Y-%m-%d")
    if period_norm == "3":  # MÃªs -> dia 1
        first = d.replace(day=1)
        return first.strftime("%Y-%m-%d")
    return d.strftime("%Y-%m-%d")

def compute_period_dates(period_norm: str, ref_date_str: Optional[str]) -> List[str]:
    """
    Retorna a lista de datas (YYYY-MM-DD) a consultar:
      1=Dia     -> [ref_date]
      2=Semana  -> [segunda..domingo]
      3=MÃªs     -> [dia1..Ãºltimodia]
    """
    d = _parse_date_yyyy_mm_dd(ref_date_str)
    if period_norm == "1":
        return [d.strftime("%Y-%m-%d")]
    if period_norm == "2":
        monday = d - timedelta(days=d.weekday())
        week = [(monday + timedelta(days=i)).strftime("%Y-%m-%d") for i in range(7)]
        return week
    if period_norm == "3":
        first = d.replace(day=1)
        last_day = calendar.monthrange(first.year, first.month)[1]
        dates = [(first + timedelta(days=i)).strftime("%Y-%m-%d") for i in range(last_day)]
        return dates
    return [d.strftime("%Y-%m-%d")]

# ---------- utilidades de formataÃ§Ã£o/estatÃ­stica jÃ¡ usadas nos renderers ----------
def _fmt_w(x) -> str:
    try:
        return f"{float(x):,.0f} W".replace(",", "X").replace(".", ",").replace("X", ".")
    except:
        return "-"

def _fmt_kwh(x) -> str:
    try:
        v = float(x)
        if v >= 1_000:
            return f"{v/1_000:.2f} MWh".replace(".", ",")
        return f"{v:.2f} kWh".replace(".", ",")
    except:
        return "-"

def _series_stats(line: dict) -> Tuple[int, float, str, float, str]:
    pts: List[dict] = line.get("xy") or []
    n = len(pts)
    if n == 0:
        return (0, float("nan"), "-", float("nan"), "-")
    max_pt = max(pts, key=lambda p: (p.get("y") if p.get("y") is not None else float("-inf")))
    min_pt = min(pts, key=lambda p: (p.get("y") if p.get("y") is not None else float("inf")))
    return (n, float(max_pt.get("y") or 0.0), str(max_pt.get("x") or "-"),
               float(min_pt.get("y") or 0.0), str(min_pt.get("x") or "-"))

def _find_line(lines: List[dict], key: str) -> Optional[dict]:
    for ln in lines or []:
        if ln.get("key") == key:
            return ln
    return None

def _safe_get_generation_income(chart_json: Dict[str, Any]) -> Tuple[Optional[float], Optional[float], str, str]:
    """Extrai (Generation, Income, unit_Gen, unit_Inc) de um JSON *diÃ¡rio*."""
    try:
        gen = chart_json["data"]["generateData"]
        gmap = {x.get("key"): x for x in gen}
        gval = gmap.get("Generation", {}).get("value")
        ival = gmap.get("Income", {}).get("value")
        gunit = gmap.get("Generation", {}).get("unit_Key") or "kWh"
        iunit = gmap.get("Income", {}).get("unit_Key") or ""
        gval = float(gval) if gval is not None else None
        ival = float(ival) if ival is not None else None
        return gval, ival, gunit, iunit
    except Exception:
        return None, None, "kWh", ""

def _extract_peak_from_line(line: Optional[dict]) -> Tuple[Optional[float], Optional[str]]:
    """Retorna (max_y, max_x) de uma linha 'xy'."""
    if not line:
        return None, None
    pts = line.get("xy") or []
    if not pts:
        return None, None
    m = max(pts, key=lambda p: p.get("y") if p.get("y") is not None else float("-inf"))
    return float(m.get("y") or 0.0), str(m.get("x") or "-")

def aggregate_power_chart_items(items: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Agrega uma lista de {date, json} (cada json = um dia do GetPlantPowerChart):
      - Soma Generation/Income.
      - Pico global em PV/Load/Battery/Meter (valor W e data/hora).
      - SOC inÃ­cio (1Âº ponto do 1Âº dia com SOC) e SOC fim (Ãºltimo ponto do Ãºltimo dia com SOC).
    """
    total_gen = 0.0
    total_inc = 0.0
    gen_unit = "kWh"
    inc_unit = ""

    def valid_json(j):
        return isinstance(j, dict) and str(j.get("code")) == "0" and not j.get("hasError", False)

    # picos
    best = {
        "PV": {"val": None, "date": None, "time": None},
        "Load": {"val": None, "date": None, "time": None},
        "Battery": {"val": None, "date": None, "time": None},
        "Meter": {"val": None, "date": None, "time": None},
    }

    # SOC global
    first_soc = None
    last_soc = None

    for entry in items:
        d = entry.get("date")
        j = entry.get("json")
        if not valid_json(j):
            continue

        # soma geraÃ§Ã£o/receita
        g, inc, gunit, iunit = _safe_get_generation_income(j)
        if g is not None: total_gen += g; gen_unit = gunit
        if inc is not None: total_inc += inc; inc_unit = iunit

        # linhas
        lines = j.get("data", {}).get("lines") or []
        pv   = _find_line(lines, "PCurve_Power_PV")
        load = _find_line(lines, "PCurve_Power_Load")
        bat  = _find_line(lines, "PCurve_Power_Battery")
        meter= _find_line(lines, "PCurve_Power_Meter")
        soc  = _find_line(lines, "PCurve_Power_SOC")

        for key, ln in (("PV", pv), ("Load", load), ("Battery", bat), ("Meter", meter)):
            peak_val, peak_time = _extract_peak_from_line(ln)
            if peak_val is None:
                continue
            cur = best[key]["val"]
            if (cur is None) or (peak_val > cur):
                best[key] = {"val": peak_val, "date": d, "time": peak_time}

        # SOC global
        if soc and soc.get("xy"):
            if first_soc is None:
                first_soc = soc["xy"][0].get("y")
            last_soc = soc["xy"][-1].get("y")

    return {
        "total_generation": total_gen,
        "generation_unit": gen_unit,
        "total_income": total_inc,
        "income_unit": inc_unit,
        "peaks": best,
        "soc": {"start": first_soc, "end": last_soc},
    }

"""### ğŸ–¼ï¸ Renderer â€” GetPlantPowerChart"""

# === 38) Renderer â€” GetPlantPowerChart (dia OU agregado) ===
from typing import Dict, Any, List

def render_plant_power_chart(chart_json: Dict[str, Any]) -> str:
    """
    Aceita:
      â€¢ JSON BRUTO do endpoint (1 dia)  -> imprime resumo do dia (igual antes).
      â€¢ BUNDLE agregado (semana/mÃªs)    -> imprime resumo do perÃ­odo (somas + picos globais).
    """
    # Detecta bundle agregado
    if chart_json.get("_period_kind") in ("week", "month"):
        kind = chart_json["_period_kind"]
        id_  = chart_json.get("_id", "-")
        sd   = chart_json.get("start_date", "-")
        ed   = chart_json.get("end_date", "-")
        agg  = chart_json.get("aggregate", {})

        gen = agg.get("total_generation")
        gunit = agg.get("generation_unit", "kWh")
        inc = agg.get("total_income")
        iunit = agg.get("income_unit", "")
        peaks = agg.get("peaks", {})
        soc   = agg.get("soc", {})

        title = "MÃªs" if kind == "month" else "Semana"
        out = []
        out.append(f"ğŸ“Š **Curvas de PotÃªncia â€” {title} {sd} â†’ {ed}**  `id={id_}`\n")
        out.append(f"â€¢ ğŸ”† GeraÃ§Ã£o total: **{_fmt_kwh(gen)}** ({gunit})")
        if inc is not None and not (isinstance(inc, float) and math.isnan(inc)):
            out.append(f"â€¢ ğŸ’° Receita total: **{inc} {iunit}**")
        out.append("")

        def _peak_line(label, p):
            if not p or p.get("val") is None:
                return None
            return f"â€¢ {label}: pico **{_fmt_w(p['val'])}** em **{p.get('date','-')} {p.get('time','-')}**"

        for lab, key in (("â˜€ï¸ PV", "PV"), ("ğŸ  Carga", "Load"), ("ğŸ”‹ Bateria", "Battery"), ("ğŸ”Œ Medidor", "Meter")):
            line = _peak_line(lab, peaks.get(key))
            if line: out.append(line)

        if soc and (soc.get("start") is not None or soc.get("end") is not None):
            out.append(f"â€¢ ğŸ“ˆ SOC: inÃ­cio **{soc.get('start','-')}%** â†’ fim **{soc.get('end','-')}%**")

        return "\n".join(out)

    # Caso contrÃ¡rio: JSON **diÃ¡rio** bruto (retrocompatÃ­vel)
    code = str(chart_json.get("code"))
    if code != "0" or chart_json.get("hasError") is True:
        return f"âš ï¸ Erro da API (code={code}): {chart_json.get('msg','')}"

    data = chart_json.get("data", {})
    lines: List[dict] = data.get("lines") or []
    gen = data.get("generateData") or []

    # data/id (quando presentes)
    ps_id = "-"
    the_date = "-"
    try:
        para = chart_json.get("components", {}).get("para")
        if para:
            model = json.loads(para).get("model", {})
            ps_id = model.get("id") or "-"
            raw_date = model.get("date")
            if raw_date:
                the_date = str(raw_date).split("T")[0]
    except Exception:
        pass

    # generateData
    gen_map = {g.get("key"): g for g in gen}
    generation = gen_map.get("Generation", {}).get("value")
    generation_unit = gen_map.get("Generation", {}).get("unit_Key") or "kWh"
    income = gen_map.get("Income", {}).get("value")
    income_unit = gen_map.get("Income", {}).get("unit_Key") or ""

    # principais sÃ©ries
    pv   = _find_line(lines, "PCurve_Power_PV")
    bat  = _find_line(lines, "PCurve_Power_Battery")
    load = _find_line(lines, "PCurve_Power_Load")
    meter= _find_line(lines, "PCurve_Power_Meter")
    soc  = _find_line(lines, "PCurve_Power_SOC")

    # estatÃ­sticas
    pv_stats    = _series_stats(pv)    if pv   else (0, float("nan"), "-", float("nan"), "-")
    bat_stats   = _series_stats(bat)   if bat  else (0, float("nan"), "-", float("nan"), "-")
    load_stats  = _series_stats(load)  if load else (0, float("nan"), "-", float("nan"), "-")
    meter_stats = _series_stats(meter) if meter else (0, float("nan"), "-", float("nan"), "-")

    # SOC diÃ¡rio
    soc_first = soc_last = None
    if soc and soc.get("xy"):
        soc_first = soc["xy"][0].get("y")
        soc_last  = soc["xy"][-1].get("y")

    out = []
    out.append(f"ğŸ“Š **Curvas de PotÃªncia â€” {the_date}**  `id={ps_id}`\n")
    out.append(f"â€¢ ğŸ”† GeraÃ§Ã£o agregada: **{_fmt_kwh(generation)}** ({generation_unit})")
    if income is not None:
        out.append(f"â€¢ ğŸ’° Receita estimada: **{income} {income_unit}**")
    out.append("")
    if pv:
        n, max_y, max_x, min_y, min_x = pv_stats
        out.append(f"â€¢ â˜€ï¸ PV (n={n}): pico **{_fmt_w(max_y)}** Ã s **{max_x}**; mÃ­nimo **{_fmt_w(min_y)}** Ã s **{min_x}**")
    if load:
        n, max_y, max_x, min_y, min_x = load_stats
        out.append(f"â€¢ ğŸ  Carga (n={n}): pico **{_fmt_w(max_y)}** Ã s **{max_x}**; mÃ­nimo **{_fmt_w(min_y)}** Ã s **{min_x}**")
    if bat:
        n, max_y, max_x, min_y, min_x = bat_stats
        out.append(f"â€¢ ğŸ”‹ Bateria (n={n}): mÃ¡x **{_fmt_w(max_y)}** Ã s **{max_x}**; mÃ­n **{_fmt_w(min_y)}** Ã s **{min_x}**")
    if meter:
        n, max_y, max_x, min_y, min_x = meter_stats
        out.append(f"â€¢ ğŸ”Œ Medidor (n={n}): mÃ¡x **{_fmt_w(max_y)}** Ã s **{max_x}**; mÃ­n **{_fmt_w(min_y)}** Ã s **{min_x}** (negativo â‰ˆ exportaÃ§Ã£o)")
    if soc is not None:
        out.append(f"â€¢ ğŸ“ˆ SOC: inÃ­cio **{soc_first}%** â†’ fim **{soc_last}%**")
    return "\n".join(out)

"""### â–¶ï¸ Uso â€” chamar a API e renderizar"""

# === 39) Uso â€” API real + render (Dia/Semana/MÃªs com agregaÃ§Ã£o automÃ¡tica) ===
auth = gw.cross_login()
print("API base regional:", auth.api_base)

chart_json = get_plant_power_chart(gw, params)  # agora agrega se perÃ­odo=2/3
print(render_plant_power_chart(chart_json))

"""### ğŸ§¾ DataFrame/CSV â€” curvas (longo) e mÃ©tricas agregadas"""

# === 40) (Opcional) DataFrame/CSV para GetPlantPowerChart (dia ou perÃ­odo agregado) ===
import pandas as pd
from pathlib import Path
from typing import Tuple

def _day_json_to_frames(day_json: Dict[str, Any]) -> Tuple[pd.DataFrame, pd.DataFrame]:
    """Converte um JSON *diÃ¡rio* em (df_lines, df_generate)."""
    data = day_json.get("data", {})
    lines = data.get("lines") or []
    gen = data.get("generateData") or []

    rows = []
    for ln in lines:
        series = ln.get("key")
        unit = ln.get("unit")
        axis = ln.get("axis")
        sort = ln.get("sort")
        for p in (ln.get("xy") or []):
            rows.append({
                "time": p.get("x"),
                "value": p.get("y"),
                "series": series,
                "unit": unit,
                "axis": axis,
                "sort": sort,
            })
    df_lines = pd.DataFrame(rows).sort_values(["time","sort"], ignore_index=True)
    df_generate = pd.DataFrame(gen)  # columns: key, value, unit_Key
    return df_lines, df_generate

def plant_power_chart_to_dataframe(chart_json: Dict[str, Any]) -> Tuple[pd.DataFrame, pd.DataFrame]:
    """
    Se for JSON diÃ¡rio â†’ frames do dia.
    Se for agregado (semana/mÃªs) â†’ concatena todos os dias com coluna 'date'.
    Retorna: (df_lines, df_generate)
    """
    if chart_json.get("_period_kind") in ("week", "month"):
        items = chart_json.get("items") or []
        all_lines = []
        all_gen = []
        for it in items:
            d = it.get("date")
            j = it.get("json")
            if not isinstance(j, dict) or str(j.get("code")) != "0" or j.get("hasError", False):
                continue
            df_l, df_g = _day_json_to_frames(j)
            if not df_l.empty:
                df_l.insert(0, "date", d)
                all_lines.append(df_l)
            if not df_g.empty:
                df_g2 = df_g.copy()
                df_g2.insert(0, "date", d)
                all_gen.append(df_g2)
        df_lines = pd.concat(all_lines, ignore_index=True) if all_lines else pd.DataFrame(columns=["date","time","value","series","unit","axis","sort"])
        df_generate = pd.concat(all_gen, ignore_index=True) if all_gen else pd.DataFrame(columns=["date","key","value","unit_Key"])
        return df_lines, df_generate

    # diÃ¡rio
    return _day_json_to_frames(chart_json)

# Exemplo:
# df_lines, df_generate = plant_power_chart_to_dataframe(chart_json)
# display(df_lines.head(), df_generate.groupby("key", as_index=False)["value"].sum())
# Path("results").mkdir(parents=True, exist_ok=True)
# df_lines.to_csv("results/PlantPowerChart_lines.csv", index=False)
# df_generate.to_csv("results/PlantPowerChart_generate.csv", index=False)
# print("âœ“ CSVs salvos em results/")